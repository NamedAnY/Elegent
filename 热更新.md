<style>
body {
  background-color: #fdf6e3; /* 整体护眼背景 */
  color: #333;
  font-family: "Microsoft YaHei", Arial, sans-serif;
  line-height: 1.6;
}

h1 {
  font-size: 28px;
  color: #3a5fcd; /* 柔和蓝紫 */
  border-left: 6px solid #ffb347;
  padding-left: 12px;
  margin-top: 30px;
  margin-bottom: 15px;
}

h2 {
  font-size: 20px;
  color: #5c3d99; /* 深紫色 */
  margin-top: 20px;
  margin-bottom: 12px;
}

h3 {
  font-size: 18px;
  color: #444;
  margin-top: 15px;
}

/* 内容卡片 */
.section {
  background: #f9fcfb; /* 浅卡片背景 */
  border: 1px solid #d3e0dc;
  border-radius: 12px;
  padding: 18px 20px;
  margin: 18px 0 28px 0;
  box-shadow: 0 3px 10px rgba(0,0,0,0.06);
  transition: transform 0.2s;
}
.section:hover {
  transform: translateY(-3px);
}

ol {
  padding-left: 22px;
}

code {
  background: #f5e6cc;
  color: #8b0000;
  padding: 3px 6px;
  border-radius: 5px;
  font-size: 90%;
}

img {
  border-radius: 10px;
  margin: 10px 0;
  box-shadow: 0 3px 10px rgba(0,0,0,0.12);
  max-width: 100%;
}
</style>

# 支持热更新项目的热更新流程

<div class="section">

本文档说明了如何在 **支持热更新的项目** 中进行热更新操作，包括流程、注意事项以及示例代码。  

</div>

## 流程
<div class="section">

1. 从 **SVN 服务器** 上拉取 `hotfix-patcher` 文件夹。  

2. 使用 **VSCode** 打开 `hotfix-patcher` 文件夹，在 `code.js` 中编写热更新代码。  

3. 运行后生成的 `data.xxxxxxx.bin` 文件，提交给续哥进行处理。  

</div>

## 注意事项
<div class="section">

### 1. classMap 配置
- 根据游戏传入的 **global 变量** 填入 `classMap.g`：一般有 `BundleJs`、`fx`、`sdk`、`window` 等。  
- 使用游戏内的 **未压缩类名** 填入 `classMap.cls`：即 TS 代码中的类名，而非混淆名。  
- 需要打补丁的函数填入到 `funcs` 数组中。  

---

### 2. 全局变量传入
- 全局变量必须在 `GScope(gVal)` 的 `gVal` 中传入。  
- 引用类时需要添加前缀，例如：`BundleJs.xxx`。  
- 未传入的全局变量可以使用 `window.xxx` 访问。  

---

### 3. 编译与语法要求
- F5 启动编译（VSCode → 运行与调试 → Launch Program）。  
- **语法限制**：  
  - 不支持 `for of`。  
  - `for` 循环前需判断数组长度 > 0。  
  - 仅支持 **ES5 语法**（不支持 `let`、模板字符串 `` ` ``、箭头函数 `()=>{}`）。  
  - `this` 只支持第一层函数，需用 `self` 替代。  

</div>

## code.js 示例
<div class="section">

```javascript
var classMap = [
{
    g: BundleJs,
    cls: 'FishingRodScript',
    funcs: [
        function onDestroy() {
            var self = this;
            self.palsyEff && self.palsyEff.destroy();
            self.barNode && self.barNode.destroy();
            self.skillBtn && self.skillBtn.destroy();
            self.cdNode && self.cdNode.destroy();
            self.img_pointer && self.img_pointer.destroy();
            self.img_fishhook && self.img_fishhook.destroy();
            self.img_fishingLine && self.img_fishingLine.destroy();
        },
        function updateFollowBtnPos(x, y) {
            var self = this;
            if (!self.skillBtn || self.skillBtn.destroyed) return;

            var stagePos = Game.mapMgr.mapPosToStagePos(self.node.x, self.node.y);
            var dir = self.dir.setValue(stagePos.x - x + 44, stagePos.y - y - 44);
            var angle = Math.atan2(dir.y, dir.x) * 180 / Math.PI + 90;

            self.skillBtn.rotation = angle;
            self.img_fishingLine.rotation = self.skillBtn.rotation + 180;
            self.img_pointer.rotation = angle + 180;

            if (fx.V2.scalarLength(dir) > 350) {
                dir.normalize(-350);
                self.skillBtn.pos(dir.x + stagePos.x + 44, dir.y + stagePos.y - 44);
            } else {
                self.skillBtn.pos(x, y);
            }
            console.log("---------鱼竿按钮位置热更---------");
        },
        function onInputUp() {
            var self = this;
            if (!self.skillBtn || self.skillBtn.destroyed) return;

            self.isDown = false;
            self.img_fishingLine.rotation = self.skillBtn.rotation + 180;
            self.skillBtn.rotation = 0;
            self.skillBtn.visible = false;
            self.img_pointer.visible = false;
            self.fishing();
        }
    ]
},
{
    g: BundleJs,
    cls: 'GameManager',
    funcs: [
        function takeDamage(from, targetData, damage) {
            var self = this;

            if (Game.gameMgr.gameStatus != BundleJs.GameStatus.E_GAME_START) return;
            if (targetData.isDie) return;
            if (targetData.invincible || targetData.invincible_skill) return;
            if (damage <= 0) return;

            if (targetData.reduceRate) {
                damage *= (1 - targetData.reduceRate);
            }

            if (targetData.type == BundleJs.BuildType.bed) {
                if (targetData.playerUuid) {
                    var playerData = Game.playerMgr.getPlayer(targetData.playerUuid)
                    if (playerData.invincibleCnt) {
                        playerData.invincibleCnt -= 1;
                        return;
                    }
                }
            }

            if (targetData.skillEquipHp) {
                targetData.skillEquipHp -= damage;
                if (targetData.skillEquipHp <= 0) {
                    targetData.skillEquipHp = 0;
                    targetData.ownerScript.changeSkin(false);
                }
            } else {
                targetData.curHp -= damage;
                targetData.curHp = Math.max(targetData.curHp, 0);

                if (self.gameMode == BundleJs.GameMode.E_Hunt && 
                    targetData.curHp > 0 && 
                    targetData.curHp / targetData.maxHp < 0.1) {
                    if (targetData == Game.playerMgr.player && !targetData.isShowYanluo) {
                        targetData.isShowYanluo = true;
                        fx.EventCenter.I.event(BundleJs.GameEvent.E_Yanluo_Show);
                    }
                }
            }

            var normalCb = new Laya.Handler(self, function () {
                targetData.isDie = (targetData.curHp == 0);
                if (targetData.owner) {
                    targetData.owner.event(BundleJs.ModelEvent.Hp_Changed, [from]);
                    targetData.owner.event(BundleJs.ModelEvent.Battle_Be_Hit, [from, damage]);
                }

                if (targetData.isDie) {
                    var data = targetData;
                    if (data.type == BundleJs.BuildType.bed && data.playerUuid) {
                        var model = Game.playerMgr.getPlayer(data.playerUuid);
                        self.takeDamage(from, model, damage);
                    }
                    if (data.type == BundleJs.BuildType.door) {
                        BundleJs.Util.playSound(121);
                        var player = Game.playerMgr.getPlayer(data.playerUuid);
                        self.heartSound(player);
                    }
                }

                if (targetData.type == BundleJs.BuildType.door && 
                    self.curHunterAtkTarget != targetData && 
                    !from.isGhost) {
                    self.curHunterAtkTarget = targetData;
                    var room = Game.mapMgr.getRoomById(targetData.roomId);
                    fx.EventCenter.I.event(BundleJs.GameEvent.E_Player_Hurt, room.bedModelList[0].playerUuid);
                }
            });

            if (!self.isOpenDoorFix && 
                BundleJs.GameMode.E_Defense == self.gameMode && 
                Game.controller.checkABTest('expt_doorFix_ad', [0, 1])) {

                var gameInfo = Game.user.gameInfo;
                var b = gameInfo.winCnt + gameInfo.failCnt > 0;

                if (b && targetData.type == BundleJs.BuildType.door && 
                    targetData.playerUuid == Game.playerMgr.mineUuid && 
                    targetData.curHp == 0) {

                    var buildResult = Game.buildingMgr.getUpgradeRet(targetData.playerUuid, targetData.x, targetData.y, false);
                    if (BundleJs.BuildResult.E_OK == buildResult) {
                        var upgradeCb = new Laya.Handler(self, function () {
                            Game.buildingMgr.upgrade(targetData.playerUuid, targetData.x, targetData.y, false, 0);
                        });
                        Game.ui.open(BundleJs.AssetUI.DoorFixDialog, { normalCb: normalCb, upgradeCb: upgradeCb });
                        self.isOpenDoorFix = true;
                    } else {
                        normalCb.run();
                    }
                } else {
                    normalCb.run();
                }
            } else {
                normalCb.run();
            }
        }
    ]
}
]

for (var index = 0; index < classMap.length; index++) {
    var info = classMap[index];
    var gVal = info.g
    var self = gVal[info.cls];
    var proto = self.prototype;
    for (var i = 0; i < info.funcs.length; i++) {
        var func = info.funcs[i];
        proto[func.name] = func;
    }
}
</div> ```